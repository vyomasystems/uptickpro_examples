//
// Generated by Bluespec Compiler, version 2023.07 (build 0eb551dc)
//
// On Tue Jul 29 14:28:18 +04 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY__start                     O     1
// tx_output_enq_ena              O     1
// tx_output_enq_data             O    70
// RDY_flush                      O     1 const
// fpu_ready                      O     1
// RDY_fpu_ready                  O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// _start_m                       I   212 reg
// tx_output_notFull_b            I     1 unused
// tx_output_enq_rdy_b            I     1
// EN__start                      I     1
// EN_flush                       I     1
//
// Combinational paths from inputs to outputs:
//   (tx_output_enq_rdy_b, EN_flush) -> tx_output_enq_ena
//   (tx_output_enq_rdy_b, EN_flush) -> tx_output_enq_data
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkfpu(CLK,
	     RST_N,

	     _start_m,
	     EN__start,
	     RDY__start,

	     tx_output_notFull_b,

	     tx_output_enq_rdy_b,

	     tx_output_enq_ena,

	     tx_output_enq_data,

	     EN_flush,
	     RDY_flush,

	     fpu_ready,
	     RDY_fpu_ready);
  input  CLK;
  input  RST_N;

  // action method _start
  input  [211 : 0] _start_m;
  input  EN__start;
  output RDY__start;

  // action method tx_output_notFull
  input  tx_output_notFull_b;

  // action method tx_output_enq_rdy
  input  tx_output_enq_rdy_b;

  // value method tx_output_enq_ena
  output tx_output_enq_ena;

  // value method tx_output_enq_data
  output [69 : 0] tx_output_enq_data;

  // action method flush
  input  EN_flush;
  output RDY_flush;

  // value method fpu_ready
  output fpu_ready;
  output RDY_fpu_ready;

  // signals for module outputs
  wire [69 : 0] tx_output_enq_data;
  wire RDY__start, RDY_flush, RDY_fpu_ready, fpu_ready, tx_output_enq_ena;

  // ports of submodule fpu
  wire [211 : 0] fpu__start_m;
  wire [69 : 0] fpu_tx_output_enq_data;
  wire fpu_EN__start,
       fpu_EN_flush,
       fpu_RDY__start,
       fpu_fpu_ready,
       fpu_tx_output_enq_ena,
       fpu_tx_output_enq_rdy_b,
       fpu_tx_output_notFull_b;

  // rule scheduling signals
  wire CAN_FIRE__start,
       CAN_FIRE_flush,
       CAN_FIRE_tx_output_enq_rdy,
       CAN_FIRE_tx_output_notFull,
       WILL_FIRE__start,
       WILL_FIRE_flush,
       WILL_FIRE_tx_output_enq_rdy,
       WILL_FIRE_tx_output_notFull;

  // action method _start
  assign RDY__start = fpu_RDY__start ;
  assign CAN_FIRE__start = fpu_RDY__start ;
  assign WILL_FIRE__start = EN__start ;

  // action method tx_output_notFull
  assign CAN_FIRE_tx_output_notFull = 1'd1 ;
  assign WILL_FIRE_tx_output_notFull = 1'd1 ;

  // action method tx_output_enq_rdy
  assign CAN_FIRE_tx_output_enq_rdy = 1'd1 ;
  assign WILL_FIRE_tx_output_enq_rdy = 1'd1 ;

  // value method tx_output_enq_ena
  assign tx_output_enq_ena = fpu_tx_output_enq_ena ;

  // value method tx_output_enq_data
  assign tx_output_enq_data = fpu_tx_output_enq_data ;

  // action method flush
  assign RDY_flush = 1'd1 ;
  assign CAN_FIRE_flush = 1'd1 ;
  assign WILL_FIRE_flush = EN_flush ;

  // value method fpu_ready
  assign fpu_ready = fpu_fpu_ready ;
  assign RDY_fpu_ready = 1'd1 ;

  // submodule fpu
  mkfpu_bsvfloat fpu(.CLK(CLK),
		     .RST_N(RST_N),
		     ._start_m(fpu__start_m),
		     .tx_output_enq_rdy_b(fpu_tx_output_enq_rdy_b),
		     .tx_output_notFull_b(fpu_tx_output_notFull_b),
		     .EN__start(fpu_EN__start),
		     .EN_flush(fpu_EN_flush),
		     .RDY__start(fpu_RDY__start),
		     .tx_output_enq_ena(fpu_tx_output_enq_ena),
		     .tx_output_enq_data(fpu_tx_output_enq_data),
		     .RDY_flush(),
		     .fpu_ready(fpu_fpu_ready),
		     .RDY_fpu_ready());

  // submodule fpu
  assign fpu__start_m = _start_m ;
  assign fpu_tx_output_enq_rdy_b = tx_output_enq_rdy_b ;
  assign fpu_tx_output_notFull_b = tx_output_notFull_b ;
  assign fpu_EN__start = EN__start ;
  assign fpu_EN_flush = EN_flush ;
endmodule  // mkfpu

