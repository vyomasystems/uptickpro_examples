//
// Generated by Bluespec Compiler, version 2023.07 (build 0eb551dc)
//
// On Tue Jul 29 14:28:00 +04 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_ma_inputs                  O     1 const
// mv_ready                       O     1
// RDY_mv_ready                   O     1 const
// mv_output_valid                O     1 reg
// RDY_mv_output_valid            O     1 const
// mv_output                      O    64 reg
// RDY_mv_output                  O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ma_inputs_in1                  I    64
// ma_inputs_in2                  I    64
// ma_inputs_funct3               I     3
// ma_inputs_wordop               I     1 reg
// EN_ma_inputs                   I     1
// EN_mv_output                   I     1
//
// Combinational paths from inputs to outputs:
//   EN_mv_output -> mv_ready
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkcombo_mul(CLK,
		   RST_N,

		   ma_inputs_in1,
		   ma_inputs_in2,
		   ma_inputs_funct3,
		   ma_inputs_wordop,
		   EN_ma_inputs,
		   RDY_ma_inputs,

		   mv_ready,
		   RDY_mv_ready,

		   mv_output_valid,
		   RDY_mv_output_valid,

		   EN_mv_output,
		   mv_output,
		   RDY_mv_output);
  input  CLK;
  input  RST_N;

  // action method ma_inputs
  input  [63 : 0] ma_inputs_in1;
  input  [63 : 0] ma_inputs_in2;
  input  [2 : 0] ma_inputs_funct3;
  input  ma_inputs_wordop;
  input  EN_ma_inputs;
  output RDY_ma_inputs;

  // value method mv_ready
  output mv_ready;
  output RDY_mv_ready;

  // value method mv_output_valid
  output mv_output_valid;
  output RDY_mv_output_valid;

  // actionvalue method mv_output
  input  EN_mv_output;
  output [63 : 0] mv_output;
  output RDY_mv_output;

  // signals for module outputs
  wire [63 : 0] mv_output;
  wire RDY_ma_inputs,
       RDY_mv_output,
       RDY_mv_output_valid,
       RDY_mv_ready,
       mv_output_valid,
       mv_ready;

  // register rg_fn3_0
  reg [2 : 0] rg_fn3_0;
  wire [2 : 0] rg_fn3_0_D_IN;
  wire rg_fn3_0_EN;

  // register rg_op1_0
  reg [64 : 0] rg_op1_0;
  wire [64 : 0] rg_op1_0_D_IN;
  wire rg_op1_0_EN;

  // register rg_op2_0
  reg [64 : 0] rg_op2_0;
  wire [64 : 0] rg_op2_0_D_IN;
  wire rg_op2_0_EN;

  // register rg_output_0
  reg [63 : 0] rg_output_0;
  wire [63 : 0] rg_output_0_D_IN;
  wire rg_output_0_EN;

  // register rg_wordop_0
  reg rg_wordop_0;
  wire rg_wordop_0_D_IN, rg_wordop_0_EN;

  // ports of submodule rg_valid_in_0
  wire rg_valid_in_0_CLR,
       rg_valid_in_0_DEQ,
       rg_valid_in_0_D_IN,
       rg_valid_in_0_D_OUT,
       rg_valid_in_0_EMPTY_N,
       rg_valid_in_0_ENQ,
       rg_valid_in_0_FULL_N;

  // ports of submodule rg_valid_out_0
  wire rg_valid_out_0_CLR,
       rg_valid_out_0_DEQ,
       rg_valid_out_0_D_IN,
       rg_valid_out_0_EMPTY_N,
       rg_valid_out_0_ENQ,
       rg_valid_out_0_FULL_N;

  // ports of submodule signed_mul
  wire [129 : 0] signed_mul_c;
  wire [64 : 0] signed_mul_a, signed_mul_b;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_perform_mul_0,
       CAN_FIRE_ma_inputs,
       CAN_FIRE_mv_output,
       WILL_FIRE_RL_rl_perform_mul_0,
       WILL_FIRE_ma_inputs,
       WILL_FIRE_mv_output;

  // remaining internal signals
  wire [63 : 0] IF_rg_fn3_0_BITS_1_TO_0_EQ_0_0_THEN_signed_mul_ETC___d14,
		default_out__h1839;
  wire [31 : 0] IF_rg_fn3_0_BITS_1_TO_0_EQ_0_0_THEN_signed_mul_ETC__q1;
  wire sign1__h2040, sign2__h2041;

  // action method ma_inputs
  assign RDY_ma_inputs = 1'd1 ;
  assign CAN_FIRE_ma_inputs = 1'd1 ;
  assign WILL_FIRE_ma_inputs = EN_ma_inputs ;

  // value method mv_ready
  assign mv_ready = rg_valid_in_0_FULL_N ;
  assign RDY_mv_ready = 1'd1 ;

  // value method mv_output_valid
  assign mv_output_valid = rg_valid_out_0_EMPTY_N ;
  assign RDY_mv_output_valid = 1'd1 ;

  // actionvalue method mv_output
  assign mv_output = rg_output_0 ;
  assign RDY_mv_output = 1'd1 ;
  assign CAN_FIRE_mv_output = 1'd1 ;
  assign WILL_FIRE_mv_output = EN_mv_output ;

  // submodule rg_valid_in_0
  FIFOL1 #(.width(32'd1)) rg_valid_in_0(.RST(RST_N),
					.CLK(CLK),
					.D_IN(rg_valid_in_0_D_IN),
					.ENQ(rg_valid_in_0_ENQ),
					.DEQ(rg_valid_in_0_DEQ),
					.CLR(rg_valid_in_0_CLR),
					.D_OUT(rg_valid_in_0_D_OUT),
					.FULL_N(rg_valid_in_0_FULL_N),
					.EMPTY_N(rg_valid_in_0_EMPTY_N));

  // submodule rg_valid_out_0
  FIFOL1 #(.width(32'd1)) rg_valid_out_0(.RST(RST_N),
					 .CLK(CLK),
					 .D_IN(rg_valid_out_0_D_IN),
					 .ENQ(rg_valid_out_0_ENQ),
					 .DEQ(rg_valid_out_0_DEQ),
					 .CLR(rg_valid_out_0_CLR),
					 .D_OUT(),
					 .FULL_N(rg_valid_out_0_FULL_N),
					 .EMPTY_N(rg_valid_out_0_EMPTY_N));

  // submodule signed_mul
  signedmul #(.AWIDTH(32'd65), .BWIDTH(32'd65)) signed_mul(.a(signed_mul_a),
							   .b(signed_mul_b),
							   .c(signed_mul_c));

  // rule RL_rl_perform_mul_0
  assign CAN_FIRE_RL_rl_perform_mul_0 =
	     rg_valid_in_0_EMPTY_N && rg_valid_out_0_FULL_N ;
  assign WILL_FIRE_RL_rl_perform_mul_0 = CAN_FIRE_RL_rl_perform_mul_0 ;

  // register rg_fn3_0
  assign rg_fn3_0_D_IN = ma_inputs_funct3 ;
  assign rg_fn3_0_EN = EN_ma_inputs ;

  // register rg_op1_0
  assign rg_op1_0_D_IN = { sign1__h2040 & ma_inputs_in1[63], ma_inputs_in1 } ;
  assign rg_op1_0_EN = EN_ma_inputs ;

  // register rg_op2_0
  assign rg_op2_0_D_IN = { sign2__h2041 & ma_inputs_in2[63], ma_inputs_in2 } ;
  assign rg_op2_0_EN = EN_ma_inputs ;

  // register rg_output_0
  assign rg_output_0_D_IN =
	     rg_wordop_0 ?
	       default_out__h1839 :
	       IF_rg_fn3_0_BITS_1_TO_0_EQ_0_0_THEN_signed_mul_ETC___d14 ;
  assign rg_output_0_EN = CAN_FIRE_RL_rl_perform_mul_0 ;

  // register rg_wordop_0
  assign rg_wordop_0_D_IN = ma_inputs_wordop ;
  assign rg_wordop_0_EN = EN_ma_inputs ;

  // submodule rg_valid_in_0
  assign rg_valid_in_0_D_IN = 1'd1 ;
  assign rg_valid_in_0_ENQ = EN_ma_inputs ;
  assign rg_valid_in_0_DEQ = CAN_FIRE_RL_rl_perform_mul_0 ;
  assign rg_valid_in_0_CLR = 1'b0 ;

  // submodule rg_valid_out_0
  assign rg_valid_out_0_D_IN = rg_valid_in_0_D_OUT ;
  assign rg_valid_out_0_ENQ = CAN_FIRE_RL_rl_perform_mul_0 ;
  assign rg_valid_out_0_DEQ = EN_mv_output ;
  assign rg_valid_out_0_CLR = 1'b0 ;

  // submodule signed_mul
  assign signed_mul_a = rg_op1_0 ;
  assign signed_mul_b = rg_op2_0 ;

  // remaining internal signals
  assign IF_rg_fn3_0_BITS_1_TO_0_EQ_0_0_THEN_signed_mul_ETC___d14 =
	     (rg_fn3_0[1:0] == 2'd0) ?
	       signed_mul_c[63:0] :
	       signed_mul_c[127:64] ;
  assign IF_rg_fn3_0_BITS_1_TO_0_EQ_0_0_THEN_signed_mul_ETC__q1 =
	     IF_rg_fn3_0_BITS_1_TO_0_EQ_0_0_THEN_signed_mul_ETC___d14[31:0] ;
  assign default_out__h1839 =
	     { {32{IF_rg_fn3_0_BITS_1_TO_0_EQ_0_0_THEN_signed_mul_ETC__q1[31]}},
	       IF_rg_fn3_0_BITS_1_TO_0_EQ_0_0_THEN_signed_mul_ETC__q1 } ;
  assign sign1__h2040 = ma_inputs_funct3[1] ^ ma_inputs_funct3[0] ;
  assign sign2__h2041 = ma_inputs_funct3[1:0] == 2'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_fn3_0 <= `BSV_ASSIGNMENT_DELAY 3'd0;
	rg_op1_0 <= `BSV_ASSIGNMENT_DELAY 65'd0;
	rg_op2_0 <= `BSV_ASSIGNMENT_DELAY 65'd0;
	rg_output_0 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_wordop_0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rg_fn3_0_EN) rg_fn3_0 <= `BSV_ASSIGNMENT_DELAY rg_fn3_0_D_IN;
	if (rg_op1_0_EN) rg_op1_0 <= `BSV_ASSIGNMENT_DELAY rg_op1_0_D_IN;
	if (rg_op2_0_EN) rg_op2_0 <= `BSV_ASSIGNMENT_DELAY rg_op2_0_D_IN;
	if (rg_output_0_EN)
	  rg_output_0 <= `BSV_ASSIGNMENT_DELAY rg_output_0_D_IN;
	if (rg_wordop_0_EN)
	  rg_wordop_0 <= `BSV_ASSIGNMENT_DELAY rg_wordop_0_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_fn3_0 = 3'h2;
    rg_op1_0 = 65'h0AAAAAAAAAAAAAAAA;
    rg_op2_0 = 65'h0AAAAAAAAAAAAAAAA;
    rg_output_0 = 64'hAAAAAAAAAAAAAAAA;
    rg_wordop_0 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkcombo_mul

