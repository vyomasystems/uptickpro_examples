//
// Generated by Bluespec Compiler, version 2023.07 (build 0eb551dc)
//
// On Tue Jul 29 14:28:07 +04 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_ma_inputs                  O     1 const
// mv_ready                       O     2
// RDY_mv_ready                   O     1 const
// tx_output_enq_ena              O     1
// tx_output_enq_data             O    64
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ma_inputs_inputs               I   132
// tx_output_notFull_b            I     1
// tx_output_enq_rdy_b            I     1
// EN_ma_inputs                   I     1
//
// Combinational paths from inputs to outputs:
//   tx_output_enq_rdy_b -> mv_ready
//   tx_output_enq_rdy_b -> tx_output_enq_ena
//   tx_output_enq_rdy_b -> tx_output_enq_data
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkmbox(CLK,
	      RST_N,

	      ma_inputs_inputs,
	      EN_ma_inputs,
	      RDY_ma_inputs,

	      mv_ready,
	      RDY_mv_ready,

	      tx_output_notFull_b,

	      tx_output_enq_rdy_b,

	      tx_output_enq_ena,

	      tx_output_enq_data);
  parameter [63 : 0] hartid = 64'b0;
  input  CLK;
  input  RST_N;

  // action method ma_inputs
  input  [131 : 0] ma_inputs_inputs;
  input  EN_ma_inputs;
  output RDY_ma_inputs;

  // value method mv_ready
  output [1 : 0] mv_ready;
  output RDY_mv_ready;

  // action method tx_output_notFull
  input  tx_output_notFull_b;

  // action method tx_output_enq_rdy
  input  tx_output_enq_rdy_b;

  // value method tx_output_enq_ena
  output tx_output_enq_ena;

  // value method tx_output_enq_data
  output [63 : 0] tx_output_enq_data;

  // signals for module outputs
  wire [63 : 0] tx_output_enq_data;
  wire [1 : 0] mv_ready;
  wire RDY_ma_inputs, RDY_mv_ready, tx_output_enq_ena;

  // inlined wires
  wire tx_mbox_out_w_ena_whas;

  // ports of submodule div_
  wire [63 : 0] div__ma_inputs_in1, div__ma_inputs_in2, div__mv_output;
  wire [2 : 0] div__ma_inputs_funct3;
  wire div__EN_ma_inputs,
       div__EN_mv_output,
       div__ma_inputs_wordop,
       div__mv_output_valid,
       div__mv_ready;

  // ports of submodule ff_ordering
  wire ff_ordering_CLR,
       ff_ordering_DEQ,
       ff_ordering_D_IN,
       ff_ordering_D_OUT,
       ff_ordering_EMPTY_N,
       ff_ordering_ENQ,
       ff_ordering_FULL_N;

  // ports of submodule mul_
  wire [63 : 0] mul__ma_inputs_in1, mul__ma_inputs_in2, mul__mv_output;
  wire [2 : 0] mul__ma_inputs_funct3;
  wire mul__EN_ma_inputs,
       mul__EN_mv_output,
       mul__ma_inputs_wordop,
       mul__mv_output_valid,
       mul__mv_ready;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_capture_output,
       CAN_FIRE_RL_rl_fifo_full,
       CAN_FIRE_ma_inputs,
       CAN_FIRE_tx_output_enq_rdy,
       CAN_FIRE_tx_output_notFull,
       WILL_FIRE_RL_rl_capture_output,
       WILL_FIRE_RL_rl_fifo_full,
       WILL_FIRE_ma_inputs,
       WILL_FIRE_tx_output_enq_rdy,
       WILL_FIRE_tx_output_notFull;

  // action method ma_inputs
  assign RDY_ma_inputs = 1'd1 ;
  assign CAN_FIRE_ma_inputs = 1'd1 ;
  assign WILL_FIRE_ma_inputs = EN_ma_inputs ;

  // value method mv_ready
  assign mv_ready =
	     { mul__mv_ready && ff_ordering_FULL_N,
	       div__mv_ready && ff_ordering_FULL_N } ;
  assign RDY_mv_ready = 1'd1 ;

  // action method tx_output_notFull
  assign CAN_FIRE_tx_output_notFull = 1'd1 ;
  assign WILL_FIRE_tx_output_notFull = 1'd1 ;

  // action method tx_output_enq_rdy
  assign CAN_FIRE_tx_output_enq_rdy = 1'd1 ;
  assign WILL_FIRE_tx_output_enq_rdy = 1'd1 ;

  // value method tx_output_enq_ena
  assign tx_output_enq_ena = tx_mbox_out_w_ena_whas ;

  // value method tx_output_enq_data
  assign tx_output_enq_data =
	     ff_ordering_D_OUT ? mul__mv_output : div__mv_output ;

  // submodule div_
  mkrestoring_div #(.hartid(hartid)) div_(.CLK(CLK),
					  .RST_N(RST_N),
					  .ma_inputs_funct3(div__ma_inputs_funct3),
					  .ma_inputs_in1(div__ma_inputs_in1),
					  .ma_inputs_in2(div__ma_inputs_in2),
					  .ma_inputs_wordop(div__ma_inputs_wordop),
					  .EN_ma_inputs(div__EN_ma_inputs),
					  .EN_mv_output(div__EN_mv_output),
					  .RDY_ma_inputs(),
					  .mv_ready(div__mv_ready),
					  .RDY_mv_ready(),
					  .mv_output_valid(div__mv_output_valid),
					  .RDY_mv_output_valid(),
					  .mv_output(div__mv_output),
					  .RDY_mv_output());

  // submodule ff_ordering
  FIFO2 #(.width(32'd1), .guarded(1'd0)) ff_ordering(.RST(RST_N),
						     .CLK(CLK),
						     .D_IN(ff_ordering_D_IN),
						     .ENQ(ff_ordering_ENQ),
						     .DEQ(ff_ordering_DEQ),
						     .CLR(ff_ordering_CLR),
						     .D_OUT(ff_ordering_D_OUT),
						     .FULL_N(ff_ordering_FULL_N),
						     .EMPTY_N(ff_ordering_EMPTY_N));

  // submodule mul_
  mkcombo_mul mul_(.CLK(CLK),
		   .RST_N(RST_N),
		   .ma_inputs_funct3(mul__ma_inputs_funct3),
		   .ma_inputs_in1(mul__ma_inputs_in1),
		   .ma_inputs_in2(mul__ma_inputs_in2),
		   .ma_inputs_wordop(mul__ma_inputs_wordop),
		   .EN_ma_inputs(mul__EN_ma_inputs),
		   .EN_mv_output(mul__EN_mv_output),
		   .RDY_ma_inputs(),
		   .mv_ready(mul__mv_ready),
		   .RDY_mv_ready(),
		   .mv_output_valid(mul__mv_output_valid),
		   .RDY_mv_output_valid(),
		   .mv_output(mul__mv_output),
		   .RDY_mv_output());

  // rule RL_rl_fifo_full
  assign CAN_FIRE_RL_rl_fifo_full = !tx_output_notFull_b ;
  assign WILL_FIRE_RL_rl_fifo_full = CAN_FIRE_RL_rl_fifo_full ;

  // rule RL_rl_capture_output
  assign CAN_FIRE_RL_rl_capture_output =
	     tx_output_enq_rdy_b && ff_ordering_EMPTY_N ;
  assign WILL_FIRE_RL_rl_capture_output = CAN_FIRE_RL_rl_capture_output ;

  // inlined wires
  assign tx_mbox_out_w_ena_whas =
	     WILL_FIRE_RL_rl_capture_output &&
	     (ff_ordering_D_OUT && mul__mv_output_valid ||
	      !ff_ordering_D_OUT && div__mv_output_valid) ;

  // submodule div_
  assign div__ma_inputs_funct3 = ma_inputs_inputs[2:0] ;
  assign div__ma_inputs_in1 = ma_inputs_inputs[130:67] ;
  assign div__ma_inputs_in2 = ma_inputs_inputs[66:3] ;
  assign div__ma_inputs_wordop = ma_inputs_inputs[131] ;
  assign div__EN_ma_inputs = EN_ma_inputs && ma_inputs_inputs[2] ;
  assign div__EN_mv_output =
	     WILL_FIRE_RL_rl_capture_output && !ff_ordering_D_OUT &&
	     div__mv_output_valid ;

  // submodule ff_ordering
  assign ff_ordering_D_IN = !ma_inputs_inputs[2] ;
  assign ff_ordering_ENQ = EN_ma_inputs ;
  assign ff_ordering_DEQ = tx_mbox_out_w_ena_whas ;
  assign ff_ordering_CLR = 1'b0 ;

  // submodule mul_
  assign mul__ma_inputs_funct3 = ma_inputs_inputs[2:0] ;
  assign mul__ma_inputs_in1 = ma_inputs_inputs[130:67] ;
  assign mul__ma_inputs_in2 = ma_inputs_inputs[66:3] ;
  assign mul__ma_inputs_wordop = ma_inputs_inputs[131] ;
  assign mul__EN_ma_inputs = EN_ma_inputs && !ma_inputs_inputs[2] ;
  assign mul__EN_mv_output =
	     WILL_FIRE_RL_rl_capture_output && ff_ordering_D_OUT &&
	     mul__mv_output_valid ;

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_fifo_full && mul__mv_output_valid)
	$display("Dynamic assertion failed: \"src/mbox/mbox.bsv\", line 65, column 42\nMUL provided result when O/P FIFO is full");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_fifo_full && mul__mv_output_valid) $finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_fifo_full && div__mv_output_valid)
	$display("Dynamic assertion failed: \"src/mbox/mbox.bsv\", line 66, column 42\nDIV provided result when O/P FIFO is full");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_fifo_full && div__mv_output_valid) $finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_inputs && !ff_ordering_FULL_N)
	$display("Dynamic assertion failed: \"src/mbox/mbox.bsv\", line 101, column 42\nEnquing MBOX inputs to full fifo");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_inputs && !ff_ordering_FULL_N) $finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mkmbox

