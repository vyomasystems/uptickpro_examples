//
// Generated by Bluespec Compiler, version 2023.07 (build 0eb551dc)
//
// On Tue Jul 29 14:27:58 +04 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_debug_tdi_i                O     1 const
// RDY_bs_chain_i                 O     1 const
// tdo                            O     1 reg
// tdo_oe                         O     1
// RDY_tdo_oe                     O     1 const
// shift_dr                       O     1
// RDY_shift_dr                   O     1 const
// pause_dr                       O     1
// RDY_pause_dr                   O     1 const
// update_dr                      O     1
// RDY_update_dr                  O     1 const
// capture_dr                     O     1
// RDY_capture_dr                 O     1 const
// extest_select                  O     1
// RDY_extest_select              O     1 const
// sample_preload_select          O     1
// RDY_sample_preload_select      O     1 const
// debug_select                   O     1
// RDY_debug_select               O     1 const
// debug_tdo                      O     1
// RDY_debug_tdo                  O     1 const
// RDY_response_from_dm           O     1 reg
// request_to_dm                  O    40 reg
// RDY_request_to_dm              O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// tms_i_tms                      I     1
// tdi_i_tdi                      I     1
// debug_tdi_i_debug_tdi          I     1 reg
// bs_chain_i_bs_chain            I     1 reg
// response_from_dm_responsedm    I    34 reg
// EN_debug_tdi_i                 I     1
// EN_bs_chain_i                  I     1
// EN_response_from_dm            I     1
// EN_request_to_dm               I     1
//
// Combinational paths from inputs to outputs:
//   tdi_i_tdi -> debug_tdo
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkjtagdtm(CLK,
		 RST_N,

		 tms_i_tms,

		 tdi_i_tdi,

		 debug_tdi_i_debug_tdi,
		 EN_debug_tdi_i,
		 RDY_debug_tdi_i,

		 bs_chain_i_bs_chain,
		 EN_bs_chain_i,
		 RDY_bs_chain_i,

		 tdo,

		 tdo_oe,
		 RDY_tdo_oe,

		 shift_dr,
		 RDY_shift_dr,

		 pause_dr,
		 RDY_pause_dr,

		 update_dr,
		 RDY_update_dr,

		 capture_dr,
		 RDY_capture_dr,

		 extest_select,
		 RDY_extest_select,

		 sample_preload_select,
		 RDY_sample_preload_select,

		 debug_select,
		 RDY_debug_select,

		 debug_tdo,
		 RDY_debug_tdo,

		 response_from_dm_responsedm,
		 EN_response_from_dm,
		 RDY_response_from_dm,

		 EN_request_to_dm,
		 request_to_dm,
		 RDY_request_to_dm);
  input  CLK;
  input  RST_N;

  // action method tms_i
  input  tms_i_tms;

  // action method tdi_i
  input  tdi_i_tdi;

  // action method debug_tdi_i
  input  debug_tdi_i_debug_tdi;
  input  EN_debug_tdi_i;
  output RDY_debug_tdi_i;

  // action method bs_chain_i
  input  bs_chain_i_bs_chain;
  input  EN_bs_chain_i;
  output RDY_bs_chain_i;

  // value method tdo
  output tdo;

  // value method tdo_oe
  output tdo_oe;
  output RDY_tdo_oe;

  // value method shift_dr
  output shift_dr;
  output RDY_shift_dr;

  // value method pause_dr
  output pause_dr;
  output RDY_pause_dr;

  // value method update_dr
  output update_dr;
  output RDY_update_dr;

  // value method capture_dr
  output capture_dr;
  output RDY_capture_dr;

  // value method extest_select
  output extest_select;
  output RDY_extest_select;

  // value method sample_preload_select
  output sample_preload_select;
  output RDY_sample_preload_select;

  // value method debug_select
  output debug_select;
  output RDY_debug_select;

  // value method debug_tdo
  output debug_tdo;
  output RDY_debug_tdo;

  // action method response_from_dm
  input  [33 : 0] response_from_dm_responsedm;
  input  EN_response_from_dm;
  output RDY_response_from_dm;

  // actionvalue method request_to_dm
  input  EN_request_to_dm;
  output [39 : 0] request_to_dm;
  output RDY_request_to_dm;

  // signals for module outputs
  wire [39 : 0] request_to_dm;
  wire RDY_bs_chain_i,
       RDY_capture_dr,
       RDY_debug_select,
       RDY_debug_tdi_i,
       RDY_debug_tdo,
       RDY_extest_select,
       RDY_pause_dr,
       RDY_request_to_dm,
       RDY_response_from_dm,
       RDY_sample_preload_select,
       RDY_shift_dr,
       RDY_tdo_oe,
       RDY_update_dr,
       capture_dr,
       debug_select,
       debug_tdo,
       extest_select,
       pause_dr,
       sample_preload_select,
       shift_dr,
       tdo,
       tdo_oe,
       update_dr;

  // inlined wires
  reg [39 : 0] dmiaccess_shiftreg_port0__write_1;
  wire [39 : 0] dmiaccess_shiftreg_port1__read,
		dmiaccess_shiftreg_port1__write_1,
		dmiaccess_shiftreg_port2__read;
  wire dmiaccess_shiftreg_EN_port0__write,
       rg_dmireset_1_whas,
       wr_dmihardreset_generated_whas,
       wr_dmireset_generated_whas;

  // register bypass_sr
  reg bypass_sr;
  wire bypass_sr_D_IN, bypass_sr_EN;

  // register capture_repsonse_from_dm
  reg capture_repsonse_from_dm;
  reg capture_repsonse_from_dm_D_IN;
  wire capture_repsonse_from_dm_EN;

  // register dmiaccess_shiftreg
  reg [39 : 0] dmiaccess_shiftreg;
  wire [39 : 0] dmiaccess_shiftreg_D_IN;
  wire dmiaccess_shiftreg_EN;

  // register dmistat
  reg [1 : 0] dmistat;
  wire [1 : 0] dmistat_D_IN;
  wire dmistat_EN;

  // register dtmcontrol_shiftreg
  reg [31 : 0] dtmcontrol_shiftreg;
  wire [31 : 0] dtmcontrol_shiftreg_D_IN;
  wire dtmcontrol_shiftreg_EN;

  // register idcode_sr
  reg [31 : 0] idcode_sr;
  reg [31 : 0] idcode_sr_D_IN;
  wire idcode_sr_EN;

  // register instruction
  reg [4 : 0] instruction;
  wire [4 : 0] instruction_D_IN;
  wire instruction_EN;

  // register instruction_shiftreg
  reg [4 : 0] instruction_shiftreg;
  wire [4 : 0] instruction_shiftreg_D_IN;
  wire instruction_shiftreg_EN;

  // register response_status
  reg [1 : 0] response_status;
  wire [1 : 0] response_status_D_IN;
  wire response_status_EN;

  // register rg_dmihardreset
  reg rg_dmihardreset;
  wire rg_dmihardreset_D_IN, rg_dmihardreset_EN;

  // register rg_dmireset
  reg rg_dmireset;
  wire rg_dmireset_D_IN, rg_dmireset_EN;

  // register rg_tdo
  reg rg_tdo;
  wire rg_tdo_D_IN, rg_tdo_EN;

  // register tapstate
  reg [3 : 0] tapstate;
  reg [3 : 0] tapstate_D_IN;
  wire tapstate_EN;

  // register wr_bs_chain_tdi
  reg wr_bs_chain_tdi;
  wire wr_bs_chain_tdi_D_IN, wr_bs_chain_tdi_EN;

  // register wr_debug_tdi
  reg wr_debug_tdi;
  wire wr_debug_tdi_D_IN, wr_debug_tdi_EN;

  // ports of submodule invert_clock
  wire invert_clock_CLK_OUT;

  // ports of submodule invert_reset
  wire invert_reset_OUT_RST;

  // ports of submodule request_to_DM
  wire [39 : 0] request_to_DM_D_IN, request_to_DM_D_OUT;
  wire request_to_DM_CLR,
       request_to_DM_DEQ,
       request_to_DM_EMPTY_N,
       request_to_DM_ENQ,
       request_to_DM_FULL_N;

  // ports of submodule response_from_DM
  wire [33 : 0] response_from_DM_D_IN, response_from_DM_D_OUT;
  wire response_from_DM_CLR,
       response_from_DM_DEQ,
       response_from_DM_EMPTY_N,
       response_from_DM_ENQ,
       response_from_DM_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_bypass_logic,
       CAN_FIRE_RL_crossed_bs_chain_tdi_clock_domain_crossing,
       CAN_FIRE_RL_crossed_bypass_sr_clock_domain_crossing,
       CAN_FIRE_RL_crossed_debug_tdi_clock_domain_crossing,
       CAN_FIRE_RL_crossed_dmiaccess_shiftreg_clock_domain_crossing,
       CAN_FIRE_RL_crossed_dtmcontrol_shiftreg_clock_domain_crossing,
       CAN_FIRE_RL_crossed_idcode_sr_clock_domain_crossing,
       CAN_FIRE_RL_crossed_instruction_clock_domain_crossing,
       CAN_FIRE_RL_crossed_instruction_shiftreg_clock_domain_crossing,
       CAN_FIRE_RL_crossed_output_tdo_clock_domain_crossing,
       CAN_FIRE_RL_crossed_tapstate_clock_domain_crossing,
       CAN_FIRE_RL_dmihardreset_generated,
       CAN_FIRE_RL_dmireset_generated,
       CAN_FIRE_RL_generate_tdo_outputpin,
       CAN_FIRE_RL_idcode_logic,
       CAN_FIRE_RL_rg_dmireset__dreg_update,
       CAN_FIRE_RL_shift_dmiaccess,
       CAN_FIRE_RL_shift_dtm,
       CAN_FIRE_RL_shift_reg,
       CAN_FIRE_RL_tap_state_machine,
       CAN_FIRE_RL_transfer_instruction_on_nedge,
       CAN_FIRE_bs_chain_i,
       CAN_FIRE_debug_tdi_i,
       CAN_FIRE_request_to_dm,
       CAN_FIRE_response_from_dm,
       CAN_FIRE_tdi_i,
       CAN_FIRE_tms_i,
       WILL_FIRE_RL_bypass_logic,
       WILL_FIRE_RL_crossed_bs_chain_tdi_clock_domain_crossing,
       WILL_FIRE_RL_crossed_bypass_sr_clock_domain_crossing,
       WILL_FIRE_RL_crossed_debug_tdi_clock_domain_crossing,
       WILL_FIRE_RL_crossed_dmiaccess_shiftreg_clock_domain_crossing,
       WILL_FIRE_RL_crossed_dtmcontrol_shiftreg_clock_domain_crossing,
       WILL_FIRE_RL_crossed_idcode_sr_clock_domain_crossing,
       WILL_FIRE_RL_crossed_instruction_clock_domain_crossing,
       WILL_FIRE_RL_crossed_instruction_shiftreg_clock_domain_crossing,
       WILL_FIRE_RL_crossed_output_tdo_clock_domain_crossing,
       WILL_FIRE_RL_crossed_tapstate_clock_domain_crossing,
       WILL_FIRE_RL_dmihardreset_generated,
       WILL_FIRE_RL_dmireset_generated,
       WILL_FIRE_RL_generate_tdo_outputpin,
       WILL_FIRE_RL_idcode_logic,
       WILL_FIRE_RL_rg_dmireset__dreg_update,
       WILL_FIRE_RL_shift_dmiaccess,
       WILL_FIRE_RL_shift_dtm,
       WILL_FIRE_RL_shift_reg,
       WILL_FIRE_RL_tap_state_machine,
       WILL_FIRE_RL_transfer_instruction_on_nedge,
       WILL_FIRE_bs_chain_i,
       WILL_FIRE_debug_tdi_i,
       WILL_FIRE_request_to_dm,
       WILL_FIRE_response_from_dm,
       WILL_FIRE_tdi_i,
       WILL_FIRE_tms_i;

  // inputs to muxes for submodule ports
  wire [1 : 0] MUX_response_status_write_1__VAL_2;
  wire MUX_capture_repsonse_from_dm_write_1__SEL_2;

  // remaining internal signals
  reg IF_instruction_EQ_0x1_99_THEN_crossed_idcode_s_ETC___d221;
  wire [39 : 0] x1__h4074, x1__h4289, x1__h4654;
  wire [33 : 0] x__h4272;
  wire [31 : 0] x__h3354, x__h3368, x__h4975;
  wire [27 : 0] r1__read__h3415;
  wire [21 : 0] r1__read__h3427;
  wire [19 : 0] r1__read__h3439;
  wire [16 : 0] r1__read__h3451;
  wire [15 : 0] r1__read__h3463;
  wire [14 : 0] r1__read__h3475;
  wire [4 : 0] x__h4780;
  wire [3 : 0] IF_wr_tms_whas__6_AND_wr_tms_wget__8_4_THEN_2__ETC___d67;
  wire [1 : 0] spliced_bits__h4349;
  wire crossed_instruction_wget__00_EQ_0x11_34_AND_re_ETC___d148,
       tapstate_EQ_3_8_AND_crossed_instruction_wget___ETC___d152,
       tapstate_EQ_3_8_AND_crossed_instruction_wget___ETC___d169,
       tapstate_EQ_3_8_AND_crossed_instruction_wget___ETC___d173,
       x__h983;

  // action method tms_i
  assign CAN_FIRE_tms_i = 1'd1 ;
  assign WILL_FIRE_tms_i = 1'd1 ;

  // action method tdi_i
  assign CAN_FIRE_tdi_i = 1'd1 ;
  assign WILL_FIRE_tdi_i = 1'd1 ;

  // action method debug_tdi_i
  assign RDY_debug_tdi_i = 1'd1 ;
  assign CAN_FIRE_debug_tdi_i = 1'd1 ;
  assign WILL_FIRE_debug_tdi_i = EN_debug_tdi_i ;

  // action method bs_chain_i
  assign RDY_bs_chain_i = 1'd1 ;
  assign CAN_FIRE_bs_chain_i = 1'd1 ;
  assign WILL_FIRE_bs_chain_i = EN_bs_chain_i ;

  // value method tdo
  assign tdo = rg_tdo ;

  // value method tdo_oe
  assign tdo_oe = tapstate == 4'd11 || tapstate == 4'd4 ;
  assign RDY_tdo_oe = 1'd1 ;

  // value method shift_dr
  assign shift_dr = tapstate == 4'd4 ;
  assign RDY_shift_dr = 1'd1 ;

  // value method pause_dr
  assign pause_dr = tapstate == 4'd6 ;
  assign RDY_pause_dr = 1'd1 ;

  // value method update_dr
  assign update_dr = tapstate == 4'd8 ;
  assign RDY_update_dr = 1'd1 ;

  // value method capture_dr
  assign capture_dr = tapstate == 4'd3 ;
  assign RDY_capture_dr = 1'd1 ;

  // value method extest_select
  assign extest_select = instruction == 5'h0 ;
  assign RDY_extest_select = 1'd1 ;

  // value method sample_preload_select
  assign sample_preload_select = instruction == 5'h02 ;
  assign RDY_sample_preload_select = 1'd1 ;

  // value method debug_select
  assign debug_select = instruction == 5'h08 ;
  assign RDY_debug_select = 1'd1 ;

  // value method debug_tdo
  assign debug_tdo = tdi_i_tdi ;
  assign RDY_debug_tdo = 1'd1 ;

  // action method response_from_dm
  assign RDY_response_from_dm = response_from_DM_FULL_N ;
  assign CAN_FIRE_response_from_dm = response_from_DM_FULL_N ;
  assign WILL_FIRE_response_from_dm = EN_response_from_dm ;

  // actionvalue method request_to_dm
  assign request_to_dm = request_to_DM_D_OUT ;
  assign RDY_request_to_dm = request_to_DM_EMPTY_N ;
  assign CAN_FIRE_request_to_dm = request_to_DM_EMPTY_N ;
  assign WILL_FIRE_request_to_dm = EN_request_to_dm ;

  // submodule invert_clock
  ClockInverter invert_clock(.CLK_IN(CLK),
			     .PREEDGE(),
			     .CLK_OUT(invert_clock_CLK_OUT));

  // submodule invert_reset
  SyncReset0 invert_reset(.IN_RST(RST_N), .OUT_RST(invert_reset_OUT_RST));

  // submodule request_to_DM
  FIFO1 #(.width(32'd40), .guarded(1'd0)) request_to_DM(.RST(RST_N),
							.CLK(CLK),
							.D_IN(request_to_DM_D_IN),
							.ENQ(request_to_DM_ENQ),
							.DEQ(request_to_DM_DEQ),
							.CLR(request_to_DM_CLR),
							.D_OUT(request_to_DM_D_OUT),
							.FULL_N(request_to_DM_FULL_N),
							.EMPTY_N(request_to_DM_EMPTY_N));

  // submodule response_from_DM
  FIFO1 #(.width(32'd34), .guarded(1'd0)) response_from_DM(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(response_from_DM_D_IN),
							   .ENQ(response_from_DM_ENQ),
							   .DEQ(response_from_DM_DEQ),
							   .CLR(response_from_DM_CLR),
							   .D_OUT(response_from_DM_D_OUT),
							   .FULL_N(response_from_DM_FULL_N),
							   .EMPTY_N(response_from_DM_EMPTY_N));

  // rule RL_crossed_tapstate_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_tapstate_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_tapstate_clock_domain_crossing = 1'd1 ;

  // rule RL_crossed_instruction_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_instruction_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_instruction_clock_domain_crossing = 1'd1 ;

  // rule RL_crossed_instruction_shiftreg_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_instruction_shiftreg_clock_domain_crossing =
	     1'd1 ;
  assign WILL_FIRE_RL_crossed_instruction_shiftreg_clock_domain_crossing =
	     1'd1 ;

  // rule RL_shift_reg
  assign CAN_FIRE_RL_shift_reg = 1'd1 ;
  assign WILL_FIRE_RL_shift_reg = 1'd1 ;

  // rule RL_crossed_bypass_sr_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_bypass_sr_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_bypass_sr_clock_domain_crossing = 1'd1 ;

  // rule RL_bypass_logic
  assign CAN_FIRE_RL_bypass_logic = 1'd1 ;
  assign WILL_FIRE_RL_bypass_logic = 1'd1 ;

  // rule RL_crossed_idcode_sr_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_idcode_sr_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_idcode_sr_clock_domain_crossing = 1'd1 ;

  // rule RL_idcode_logic
  assign CAN_FIRE_RL_idcode_logic = 1'd1 ;
  assign WILL_FIRE_RL_idcode_logic = 1'd1 ;

  // rule RL_crossed_bs_chain_tdi_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_bs_chain_tdi_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_bs_chain_tdi_clock_domain_crossing = 1'd1 ;

  // rule RL_crossed_debug_tdi_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_debug_tdi_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_debug_tdi_clock_domain_crossing = 1'd1 ;

  // rule RL_crossed_dtmcontrol_shiftreg_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_dtmcontrol_shiftreg_clock_domain_crossing =
	     1'd1 ;
  assign WILL_FIRE_RL_crossed_dtmcontrol_shiftreg_clock_domain_crossing =
	     1'd1 ;

  // rule RL_shift_dtm
  assign CAN_FIRE_RL_shift_dtm = 1'd1 ;
  assign WILL_FIRE_RL_shift_dtm = 1'd1 ;

  // rule RL_dmihardreset_generated
  assign CAN_FIRE_RL_dmihardreset_generated = wr_dmihardreset_generated_whas ;
  assign WILL_FIRE_RL_dmihardreset_generated =
	     wr_dmihardreset_generated_whas && !EN_request_to_dm ;

  // rule RL_rg_dmireset__dreg_update
  assign CAN_FIRE_RL_rg_dmireset__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_rg_dmireset__dreg_update = 1'd1 ;

  // rule RL_crossed_output_tdo_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_output_tdo_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_output_tdo_clock_domain_crossing = 1'd1 ;

  // rule RL_generate_tdo_outputpin
  assign CAN_FIRE_RL_generate_tdo_outputpin = 1'd1 ;
  assign WILL_FIRE_RL_generate_tdo_outputpin = 1'd1 ;

  // rule RL_transfer_instruction_on_nedge
  assign CAN_FIRE_RL_transfer_instruction_on_nedge = 1'd1 ;
  assign WILL_FIRE_RL_transfer_instruction_on_nedge = 1'd1 ;

  // rule RL_crossed_dmiaccess_shiftreg_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_dmiaccess_shiftreg_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_dmiaccess_shiftreg_clock_domain_crossing =
	     1'd1 ;

  // rule RL_shift_dmiaccess
  assign CAN_FIRE_RL_shift_dmiaccess = !wr_dmihardreset_generated_whas ;
  assign WILL_FIRE_RL_shift_dmiaccess = CAN_FIRE_RL_shift_dmiaccess ;

  // rule RL_tap_state_machine
  assign CAN_FIRE_RL_tap_state_machine = 1'd1 ;
  assign WILL_FIRE_RL_tap_state_machine = 1'd1 ;

  // rule RL_dmireset_generated
  assign CAN_FIRE_RL_dmireset_generated = wr_dmireset_generated_whas ;
  assign WILL_FIRE_RL_dmireset_generated = wr_dmireset_generated_whas ;

  // inputs to muxes for submodule ports
  assign MUX_capture_repsonse_from_dm_write_1__SEL_2 =
	     WILL_FIRE_RL_shift_dmiaccess && tapstate != 4'd0 &&
	     tapstate_EQ_3_8_AND_crossed_instruction_wget___ETC___d169 ;
  assign MUX_response_status_write_1__VAL_2 =
	     response_from_DM_EMPTY_N ? spliced_bits__h4349 : 2'd3 ;

  // inlined wires
  assign wr_dmihardreset_generated_whas =
	     tapstate == 4'd8 && instruction == 5'h10 &&
	     dtmcontrol_shiftreg[17] ;
  assign wr_dmireset_generated_whas =
	     tapstate == 4'd8 && instruction == 5'h10 &&
	     dtmcontrol_shiftreg[16] ;
  assign rg_dmireset_1_whas =
	     tapstate == 4'd0 || tapstate == 4'd8 && instruction == 5'h10 ;
  assign dmiaccess_shiftreg_EN_port0__write =
	     WILL_FIRE_RL_shift_dmiaccess &&
	     (tapstate == 4'd0 ||
	      tapstate_EQ_3_8_AND_crossed_instruction_wget___ETC___d152) ;
  always@(tapstate or x1__h4654 or x1__h4289 or x1__h4074)
  begin
    case (tapstate)
      4'd0: dmiaccess_shiftreg_port0__write_1 = 40'd0;
      4'd3: dmiaccess_shiftreg_port0__write_1 = x1__h4289;
      4'd4: dmiaccess_shiftreg_port0__write_1 = x1__h4074;
      default: dmiaccess_shiftreg_port0__write_1 = x1__h4654;
    endcase
  end
  assign dmiaccess_shiftreg_port1__read =
	     dmiaccess_shiftreg_EN_port0__write ?
	       dmiaccess_shiftreg_port0__write_1 :
	       dmiaccess_shiftreg ;
  assign dmiaccess_shiftreg_port1__write_1 =
	     { dmiaccess_shiftreg_port1__read[39:2], 2'd0 } ;
  assign dmiaccess_shiftreg_port2__read =
	     wr_dmireset_generated_whas ?
	       dmiaccess_shiftreg_port1__write_1 :
	       dmiaccess_shiftreg_port1__read ;

  // register bypass_sr
  assign bypass_sr_D_IN = tapstate != 4'd0 && tapstate != 4'd3 && tdi_i_tdi ;
  assign bypass_sr_EN =
	     tapstate == 4'd0 ||
	     (tapstate == 4'd3 || tapstate == 4'd4) && instruction == 5'h1F ;

  // register capture_repsonse_from_dm
  always@(wr_dmireset_generated_whas or
	  MUX_capture_repsonse_from_dm_write_1__SEL_2 or
	  tapstate or WILL_FIRE_RL_dmihardreset_generated)
  case (1'b1)
    wr_dmireset_generated_whas: capture_repsonse_from_dm_D_IN = 1'd0;
    MUX_capture_repsonse_from_dm_write_1__SEL_2:
	capture_repsonse_from_dm_D_IN = tapstate != 4'd3;
    WILL_FIRE_RL_dmihardreset_generated: capture_repsonse_from_dm_D_IN = 1'd0;
    default: capture_repsonse_from_dm_D_IN = 1'bx /* unspecified value */ ;
  endcase
  assign capture_repsonse_from_dm_EN =
	     WILL_FIRE_RL_shift_dmiaccess && tapstate != 4'd0 &&
	     tapstate_EQ_3_8_AND_crossed_instruction_wget___ETC___d169 ||
	     WILL_FIRE_RL_dmihardreset_generated ||
	     wr_dmireset_generated_whas ;

  // register dmiaccess_shiftreg
  assign dmiaccess_shiftreg_D_IN = dmiaccess_shiftreg_port2__read ;
  assign dmiaccess_shiftreg_EN = 1'b1 ;

  // register dmistat
  assign dmistat_D_IN = spliced_bits__h4349 ;
  assign dmistat_EN =
	     WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	     instruction == 5'h11 &&
	     response_from_DM_EMPTY_N ;

  // register dtmcontrol_shiftreg
  assign dtmcontrol_shiftreg_D_IN = (tapstate == 4'd3) ? x__h3354 : x__h3368 ;
  assign dtmcontrol_shiftreg_EN =
	     (tapstate == 4'd3 || tapstate == 4'd4) && instruction == 5'h10 ;

  // register idcode_sr
  always@(tapstate or x__h4975)
  begin
    case (tapstate)
      4'd0, 4'd3: idcode_sr_D_IN = 32'h100039D3;
      default: idcode_sr_D_IN = x__h4975;
    endcase
  end
  assign idcode_sr_EN =
	     tapstate == 4'd0 ||
	     (tapstate == 4'd3 || tapstate == 4'd4) && instruction == 5'h01 ;

  // register instruction
  assign instruction_D_IN =
	     (tapstate == 4'd0) ? 5'h01 : instruction_shiftreg ;
  assign instruction_EN = tapstate == 4'd0 || tapstate == 4'd15 ;

  // register instruction_shiftreg
  assign instruction_shiftreg_D_IN =
	     (tapstate == 4'd10) ? 5'b10101 : x__h4780 ;
  assign instruction_shiftreg_EN = tapstate == 4'd10 || tapstate == 4'd11 ;

  // register response_status
  assign response_status_D_IN =
	     wr_dmireset_generated_whas ?
	       2'd0 :
	       MUX_response_status_write_1__VAL_2 ;
  assign response_status_EN =
	     WILL_FIRE_RL_shift_dmiaccess &&
	     tapstate_EQ_3_8_AND_crossed_instruction_wget___ETC___d173 ||
	     wr_dmireset_generated_whas ;

  // register rg_dmihardreset
  assign rg_dmihardreset_D_IN = tapstate != 4'd0 && dtmcontrol_shiftreg[17] ;
  assign rg_dmihardreset_EN = rg_dmireset_1_whas ;

  // register rg_dmireset
  assign rg_dmireset_D_IN = rg_dmireset_1_whas && x__h983 ;
  assign rg_dmireset_EN = 1'd1 ;

  // register rg_tdo
  assign rg_tdo_D_IN =
	     (tapstate == 4'd11) ?
	       instruction_shiftreg[0] :
	       IF_instruction_EQ_0x1_99_THEN_crossed_idcode_s_ETC___d221 ;
  assign rg_tdo_EN = 1'd1 ;

  // register tapstate
  always@(tapstate or
	  tms_i_tms or
	  IF_wr_tms_whas__6_AND_wr_tms_wget__8_4_THEN_2__ETC___d67)
  begin
    case (tapstate)
      4'd0: tapstate_D_IN = 4'd1;
      4'd1: tapstate_D_IN = 4'd2;
      4'd2: tapstate_D_IN = tms_i_tms ? 4'd9 : 4'd3;
      4'd3: tapstate_D_IN = tms_i_tms ? 4'd5 : 4'd4;
      4'd4: tapstate_D_IN = 4'd5;
      4'd5: tapstate_D_IN = tms_i_tms ? 4'd8 : 4'd6;
      4'd6: tapstate_D_IN = 4'd7;
      4'd7: tapstate_D_IN = tms_i_tms ? 4'd8 : 4'd4;
      4'd8, 4'd15:
	  tapstate_D_IN =
	      IF_wr_tms_whas__6_AND_wr_tms_wget__8_4_THEN_2__ETC___d67;
      4'd9: tapstate_D_IN = tms_i_tms ? 4'd0 : 4'd10;
      4'd10: tapstate_D_IN = tms_i_tms ? 4'd12 : 4'd11;
      4'd11: tapstate_D_IN = 4'd12;
      4'd12: tapstate_D_IN = tms_i_tms ? 4'd15 : 4'd13;
      4'd13: tapstate_D_IN = 4'd14;
      4'd14: tapstate_D_IN = tms_i_tms ? 4'd15 : 4'd11;
    endcase
  end
  assign tapstate_EN =
	     tapstate == 4'd0 && !tms_i_tms ||
	     tapstate != 4'd0 &&
	     (tapstate == 4'd1 && tms_i_tms ||
	      tapstate != 4'd1 &&
	      (tapstate == 4'd4 && tms_i_tms ||
	       tapstate != 4'd4 &&
	       (tapstate == 4'd6 && tms_i_tms ||
		tapstate != 4'd6 &&
		(tapstate == 4'd11 && tms_i_tms ||
		 tapstate != 4'd11 && (tms_i_tms || tapstate != 4'd13))))) ;

  // register wr_bs_chain_tdi
  assign wr_bs_chain_tdi_D_IN = bs_chain_i_bs_chain ;
  assign wr_bs_chain_tdi_EN = EN_bs_chain_i ;

  // register wr_debug_tdi
  assign wr_debug_tdi_D_IN = debug_tdi_i_debug_tdi ;
  assign wr_debug_tdi_EN = EN_debug_tdi_i ;

  // submodule request_to_DM
  assign request_to_DM_D_IN = dmiaccess_shiftreg ;
  assign request_to_DM_ENQ =
	     WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	     crossed_instruction_wget__00_EQ_0x11_34_AND_re_ETC___d148 ;
  assign request_to_DM_DEQ =
	     WILL_FIRE_RL_dmihardreset_generated || EN_request_to_dm ;
  assign request_to_DM_CLR = 1'b0 ;

  // submodule response_from_DM
  assign response_from_DM_D_IN = response_from_dm_responsedm ;
  assign response_from_DM_ENQ =
	     EN_response_from_dm && capture_repsonse_from_dm ;
  assign response_from_DM_DEQ =
	     WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	     instruction == 5'h11 &&
	     response_from_DM_EMPTY_N ||
	     WILL_FIRE_RL_dmihardreset_generated ;
  assign response_from_DM_CLR = 1'b0 ;

  // remaining internal signals
  assign IF_wr_tms_whas__6_AND_wr_tms_wget__8_4_THEN_2__ETC___d67 =
	     tms_i_tms ? 4'd2 : 4'd1 ;
  assign crossed_instruction_wget__00_EQ_0x11_34_AND_re_ETC___d148 =
	     instruction == 5'h11 && request_to_DM_FULL_N &&
	     dmiaccess_shiftreg[1:0] != 2'd0 &&
	     !capture_repsonse_from_dm ;
  assign r1__read__h3415 = { r1__read__h3427, 6'd6 } ;
  assign r1__read__h3427 = { r1__read__h3439, dmistat } ;
  assign r1__read__h3439 = { r1__read__h3451, 3'd7 } ;
  assign r1__read__h3451 = { r1__read__h3463, 1'd0 } ;
  assign r1__read__h3463 = { r1__read__h3475, rg_dmireset } ;
  assign r1__read__h3475 = { 14'd0, rg_dmihardreset } ;
  assign spliced_bits__h4349 = response_from_DM_D_OUT[1:0] | response_status ;
  assign tapstate_EQ_3_8_AND_crossed_instruction_wget___ETC___d152 =
	     tapstate == 4'd3 && instruction == 5'h11 &&
	     response_from_DM_EMPTY_N ||
	     tapstate == 4'd4 && instruction == 5'h11 ||
	     tapstate == 4'd8 &&
	     crossed_instruction_wget__00_EQ_0x11_34_AND_re_ETC___d148 ;
  assign tapstate_EQ_3_8_AND_crossed_instruction_wget___ETC___d169 =
	     tapstate == 4'd3 && instruction == 5'h11 &&
	     response_from_DM_EMPTY_N ||
	     tapstate == 4'd8 &&
	     crossed_instruction_wget__00_EQ_0x11_34_AND_re_ETC___d148 ;
  assign tapstate_EQ_3_8_AND_crossed_instruction_wget___ETC___d173 =
	     tapstate == 4'd3 && instruction == 5'h11 &&
	     (response_from_DM_EMPTY_N || capture_repsonse_from_dm) ;
  assign x1__h4074 = { tdi_i_tdi, dmiaccess_shiftreg[39:1] } ;
  assign x1__h4289 = { dmiaccess_shiftreg[39:34], x__h4272 } ;
  assign x1__h4654 = { dmiaccess_shiftreg[39:2], 2'd3 } ;
  assign x__h3354 = { r1__read__h3415, 4'd1 } ;
  assign x__h3368 = { tdi_i_tdi, dtmcontrol_shiftreg[31:1] } ;
  assign x__h4272 = { response_from_DM_D_OUT[33:2], spliced_bits__h4349 } ;
  assign x__h4780 = { tdi_i_tdi, instruction_shiftreg[4:1] } ;
  assign x__h4975 = { tdi_i_tdi, idcode_sr[31:1] } ;
  assign x__h983 = tapstate != 4'd0 && dtmcontrol_shiftreg[16] ;
  always@(instruction or
	  bypass_sr or
	  wr_bs_chain_tdi or
	  idcode_sr or
	  wr_debug_tdi or dtmcontrol_shiftreg or dmiaccess_shiftreg)
  begin
    case (instruction)
      5'h0, 5'h02:
	  IF_instruction_EQ_0x1_99_THEN_crossed_idcode_s_ETC___d221 =
	      wr_bs_chain_tdi;
      5'h01:
	  IF_instruction_EQ_0x1_99_THEN_crossed_idcode_s_ETC___d221 =
	      idcode_sr[0];
      5'h08:
	  IF_instruction_EQ_0x1_99_THEN_crossed_idcode_s_ETC___d221 =
	      wr_debug_tdi;
      5'h10:
	  IF_instruction_EQ_0x1_99_THEN_crossed_idcode_s_ETC___d221 =
	      dtmcontrol_shiftreg[0];
      5'h11:
	  IF_instruction_EQ_0x1_99_THEN_crossed_idcode_s_ETC___d221 =
	      dmiaccess_shiftreg[0];
      5'h1F:
	  IF_instruction_EQ_0x1_99_THEN_crossed_idcode_s_ETC___d221 =
	      bypass_sr;
      default: IF_instruction_EQ_0x1_99_THEN_crossed_idcode_s_ETC___d221 =
		   bypass_sr;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK or `BSV_RESET_EDGE RST_N)
  if (RST_N == `BSV_RESET_VALUE)
    begin
      bypass_sr <= `BSV_ASSIGNMENT_DELAY 1'd0;
      capture_repsonse_from_dm <= `BSV_ASSIGNMENT_DELAY 1'd0;
      dmiaccess_shiftreg <= `BSV_ASSIGNMENT_DELAY 40'd2;
      dmistat <= `BSV_ASSIGNMENT_DELAY 2'd0;
      dtmcontrol_shiftreg <= `BSV_ASSIGNMENT_DELAY 32'd28769;
      idcode_sr <= `BSV_ASSIGNMENT_DELAY 32'h100039D3;
      instruction_shiftreg <= `BSV_ASSIGNMENT_DELAY 5'd0;
      response_status <= `BSV_ASSIGNMENT_DELAY 2'd0;
      rg_dmihardreset <= `BSV_ASSIGNMENT_DELAY 1'd0;
      rg_dmireset <= `BSV_ASSIGNMENT_DELAY 1'd0;
      tapstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
      wr_bs_chain_tdi <= `BSV_ASSIGNMENT_DELAY 1'd0;
      wr_debug_tdi <= `BSV_ASSIGNMENT_DELAY 1'd0;
    end
  else
    begin
      if (bypass_sr_EN) bypass_sr <= `BSV_ASSIGNMENT_DELAY bypass_sr_D_IN;
      if (capture_repsonse_from_dm_EN)
	capture_repsonse_from_dm <= `BSV_ASSIGNMENT_DELAY
	    capture_repsonse_from_dm_D_IN;
      if (dmiaccess_shiftreg_EN)
	dmiaccess_shiftreg <= `BSV_ASSIGNMENT_DELAY dmiaccess_shiftreg_D_IN;
      if (dmistat_EN) dmistat <= `BSV_ASSIGNMENT_DELAY dmistat_D_IN;
      if (dtmcontrol_shiftreg_EN)
	dtmcontrol_shiftreg <= `BSV_ASSIGNMENT_DELAY dtmcontrol_shiftreg_D_IN;
      if (idcode_sr_EN) idcode_sr <= `BSV_ASSIGNMENT_DELAY idcode_sr_D_IN;
      if (instruction_shiftreg_EN)
	instruction_shiftreg <= `BSV_ASSIGNMENT_DELAY
	    instruction_shiftreg_D_IN;
      if (response_status_EN)
	response_status <= `BSV_ASSIGNMENT_DELAY response_status_D_IN;
      if (rg_dmihardreset_EN)
	rg_dmihardreset <= `BSV_ASSIGNMENT_DELAY rg_dmihardreset_D_IN;
      if (rg_dmireset_EN)
	rg_dmireset <= `BSV_ASSIGNMENT_DELAY rg_dmireset_D_IN;
      if (tapstate_EN) tapstate <= `BSV_ASSIGNMENT_DELAY tapstate_D_IN;
      if (wr_bs_chain_tdi_EN)
	wr_bs_chain_tdi <= `BSV_ASSIGNMENT_DELAY wr_bs_chain_tdi_D_IN;
      if (wr_debug_tdi_EN)
	wr_debug_tdi <= `BSV_ASSIGNMENT_DELAY wr_debug_tdi_D_IN;
    end

  always@(posedge invert_clock_CLK_OUT or
	  `BSV_RESET_EDGE invert_reset_OUT_RST)
  if (invert_reset_OUT_RST == `BSV_RESET_VALUE)
    begin
      instruction <= `BSV_ASSIGNMENT_DELAY 5'h01;
      rg_tdo <= `BSV_ASSIGNMENT_DELAY 1'd0;
    end
  else
    begin
      if (instruction_EN)
	instruction <= `BSV_ASSIGNMENT_DELAY instruction_D_IN;
      if (rg_tdo_EN) rg_tdo <= `BSV_ASSIGNMENT_DELAY rg_tdo_D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    bypass_sr = 1'h0;
    capture_repsonse_from_dm = 1'h0;
    dmiaccess_shiftreg = 40'hAAAAAAAAAA;
    dmistat = 2'h2;
    dtmcontrol_shiftreg = 32'hAAAAAAAA;
    idcode_sr = 32'hAAAAAAAA;
    instruction = 5'h0A;
    instruction_shiftreg = 5'h0A;
    response_status = 2'h2;
    rg_dmihardreset = 1'h0;
    rg_dmireset = 1'h0;
    rg_tdo = 1'h0;
    tapstate = 4'hA;
    wr_bs_chain_tdi = 1'h0;
    wr_debug_tdi = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkjtagdtm

